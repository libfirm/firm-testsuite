#!/usr/bin/env python

from glob import iglob as glob
from threading import Thread
import os
import sys
import time
import xml.etree.ElementTree as ET
import difflib
import optparse
import codecs
from datetime import datetime
from time import time
import re
import multiprocessing
import itertools

from util.concurrent.futures import ProcessPoolExecutor
from util.shell import silent_shell, execute, SigKill

from copy import deepcopy
_XML_ENCODING="utf-8"
try:
	from urllib import urlopen
except ImportError: # Python3
	from urllib.request import urlopen
	# use the control flow for more python3 stuff ;)
	_XML_ENCODING="unicode"

_DEFAULT_DIRS = [
	"backend",
	"opt",
	"C",
	"C/pragmatic",
	"C/should_fail",
	"C/should_warn",
	"C/nowarn",
	"C/gnu90",
	"C/gnu99",
	"C++/should_fail",
	"ack",
	"langshootout",
	"llvm",
	"gcc" ]
_ARCH_DIRS = [
	"x86code" ]
_DEBUG = None
_VERBOSE = None
TESTS = []
_REPORT_NAME = "stats-" +  datetime.now().strftime("%Y.%m.%d")
_EMBEDDED_CMD = re.compile("/\\*\\$ (.+) \\$\\*/")
_CMD = re.compile("(!?check(\[[0-9]+\])?|shell|cflags|ldflags)(.*)")

configurations = dict()
out=sys.stdout

_OPTS = optparse.OptionParser(version="%prog 0.1", usage="%prog [options]")
_OPTS.set_defaults(
	debug=False,
	verbose=False,
	threads=multiprocessing.cpu_count() + 1,
	show_disappeared=False,
	compiler="cparser",
	reportdir="reports/",
	builddir="build/",
	faillog_out=None,
	cflags="",
	ldflags="-lm",
	expect_url="http://pp.info.uni-karlsruhe.de/git/firm-testresults/plain/fail_expectations-i686-linux-gnu",
	runexe="")
_OPTS.add_option("-d", "--debug", dest="debug", action="store_true",
                 help="Enable debug messages")
_OPTS.add_option("-v", "--verbose", dest="verbose", action="store_true",
                 help="More output")
_OPTS.add_option("-c", "--compile-times", dest="compile_times",
                 action="store_true",
                 help="Display compile time of each program")
_OPTS.add_option("-t", "--threads", dest="threads", type="int",
                 help="Number of threads to use")
_OPTS.add_option("--faillog", dest="faillog_out",
                 help="Write faillog into file specified here")
_OPTS.add_option("--expect", dest="expect_url",
                 help="file/url with fail expectations")
_OPTS.add_option("--cflags", dest="cflags",
                 help="Use CFLAGS to compile test programs", metavar="CFLAGS")
_OPTS.add_option("--ldflags", dest="ldflags",
                 help="Use LDFLAGS to compile test programs", metavar="LDFLAGS")
_OPTS.add_option("--compiler", dest="compiler",
                 help="Use COMPILER to compile test programs",
                 metavar="COMPILER")
_OPTS.add_option("--show-disappeared", dest="show_disappeared",
                 action="store_true", help="show disappeared tests")

def ensure_dir(name):
	try:
		os.makedirs(name)
	except Exception:
		pass
	if not os.path.isdir(name):
		sys.stderr.write("Error: '%s' is not a directory\n" % name)
		sys.exit(1)

def my_execute(cmd, env=None, timeout=0):
	if _DEBUG:
		out.write(cmd + "\n")
	return execute(cmd,env,timeout)

class Test(object):
	def __init__(self, filename, environment):
		self.environment = environment
		self.id = filename
		self.compile_seconds = -1
		self.run_seconds = -1
		self.checks = []
		self.shell_cmds = []

		environment.executionargs = ""

		environment.filename = filename
		if os.path.isfile(filename+".ref"):
			environment.reference_output = codecs.open(filename+".ref", "r").read()
		environment.executable = environment.builddir + "/" + environment.filename + ".exe"
		self._parse_embedded_commands(filename)

	def _add_check(self, regex, count_arg, flag):
		"""add a check for regex."""
		c = 0
		if count_arg:
			if flag:
				c = int(count_arg[1:-1])
			else:
				out.write("!check cannot be used with an argument\n")
		if _DEBUG:
			if flag:
				if c > 0:
					out.write("Adding to checks: check[%d] %s\n" % (c, regex))
				else:
					out.write("Adding to checks: check %s\n" % regex)
			else:
				out.write("Adding to checks: !check %s\n" % regex)
		self.checks.append((re.compile(regex), flag, c, regex))
		if not hasattr(self.environment, 'asm_file'):
			self.environment.asm_file = self.environment.builddir + "/" + self.environment.filename + ".s"

	def _add_shell_cmd(self, cmd):
		"""execute the given command."""
		if _DEBUG:
			out.write("Adding to shell commands: '%s'\n" % cmd)
		self.shell_cmds.append(cmd)
		if not hasattr(self.environment, 'asm_file'):
			self.environment.asm_file = self.environment.builddir + "/" + self.environment.filename + ".s"

	def _add_cflags(self, flags):
		"""Add to cflags"""
		if _DEBUG:
			out.write("Adding to cflags: '%s'\n" % flags)
		self.environment.cflags += " " + flags

	def _add_ldflags(self, flags):
		"""Add to ldflags"""
		if _DEBUG:
			out.write("Adding to ldflags: '%s'\n" % flags)
		self.environment.ldflags += " " + flags

	def _parse_embedded_command(self, cmd):
		"""parse one /*$ $*/ embedded command"""
		m = _CMD.match(cmd)
		if m:
			base = m.group(1)
			if m.group(2):
				base = base[0:-len(m.group(2))]
			if base == "check":
				self._add_check(m.group(3).strip(), m.group(2), True)
			elif base == "!check":
				self._add_check(m.group(3).strip(), m.group(2), False)
			elif base == "shell":
				self._add_shell_cmd(m.group(3).strip())
			elif base == "cflags":
				self._add_cflags(m.group(3).strip())
			elif base == "ldflags":
				self._add_ldflags(m.group(3).strip())
			else:
				out.write("Error: unsupported command %s\n" % (base))
		else:
			# treat as a cflag option
			self._add_cflags(cmd.strip())

	def _parse_embedded_commands(self, filename):
		"""check input for /*$ $*/ embedded command and parse them."""
		for line in codecs.open(filename, encoding="utf-8"):
			m = _EMBEDDED_CMD.match(line)
			if m:
				if _DEBUG:
					out.write("Processing embedded cmd: %s\n" % (m.group(1)))
				self._parse_embedded_command(m.group(1))

	def run(self):
		self.success = False
		self.error_msg = "ok"
		c = self._test_compile()
		if not c: return
		c = self.check_compiler_errors()
		if not c: return
		c = self._test_reference_output()
		if not c: return
		c = self._test_shell_commands()
		if not c: return
		c = self._test_check_commands()
		if not c: return
		self.success = True

	def _test_compile(self):
		"""Compile the test program"""
		start = time()
		c = self.compile()
		self.compile_seconds = time() - start
		self.long_error_msg = "\n".join((self.compile_command, self.compiling))
		if not c: return c
		return True

	def _test_reference_output(self):
		"""Run test program and compare output to reference"""
		environment = self.environment
		start = time()
		r = self.check_execution()
		self.run_seconds = time() - start
		return r

	def _test_check_commands(self):
		"""Execute all embedded check commands"""
		if len(self.checks) == 0:
			return True

		self._compile_asm()
		asm_name = "%(asm_file)s" % self.environment.__dict__
		for regex, flag, c, txt in self.checks:
			if _DEBUG:
				prefix = "checking !"
				if flag: prefix = "checking"
				if c > 0: prefix += " %d *" % c
				out.write("%s '%s'\n" % (prefix, txt))
			s = self._grep_asm(asm_name, regex, c)
			if flag != s:
				prefix = "!check"
				if flag: prefix = "check"
				if c > 0: prefix += "[%d]" % c
				self.error_msg = "%s '%s' failed" % (prefix, txt)
				return False
		return True

	def _test_shell_commands(self):
		"""Execute all embedded shell commands"""
		if len(self.shell_cmds) == 0:
			return True

		self._compile_asm()
		for txt in self.shell_cmds:
			cmd = txt % self.environment.__dict__
			if _DEBUG:
				out.write("shell %s\n" % (txt))
			ret = silent_shell(cmd)
			if ret != 0:
				self.error_msg = "shell '%s' failed" % cmd
				return False
		return True

	def _grep_asm(self, asm_name, regex, count):
		"""Check for regex in the generated assembler file."""
		if count > 0:
			for line in open(asm_name):
				if regex.search(line):
					count -= 1
			return count == 0
		else:
			for line in open(asm_name):
				if regex.search(line):
					return True
		return False

	def compile(self):
		"""Compile the test program"""
		environment = self.environment
		cmd = "%(compiler)s %(filename)s %(cflags)s %(ldflags)s -o %(executable)s" % environment.__dict__
		self.compile_command = cmd
		self.compiling = ""
		try:
			ensure_dir(os.path.dirname(environment.executable))
			self.compile_out, self.compile_err, self.compile_retcode = my_execute(cmd, timeout=60)
		except SigKill as e:
			self.error_msg = "compiler: %s" % (e.name)
			self.long_error_msg = "\n".join((self.compile_command, self.compiling))
			return False
		except MemoryError as e:
			self.error_msg = "compiler: out of memory"
			self.long_error_msg = "\n".join((self.compile_command, self.compiling))
			return False
		except OSError as e:
			self.error_msg = "compilation failed (%s)" % (e.strerror)
			self.long_error_msg = "\n".join((self.compile_command, self.compiling))
			return False
		c = self.parse_compiler_output()
		if not c: return c

		return True

	def parse_compiler_output(self):
		# Compiled. Now check the compiler output.
		self.warnings = []
		self.errors = []
		self.compiling = "\n".join(self.compile_out)
		for line in self.compile_err.splitlines() + self.compile_out.splitlines():
			if ": warning: " in line: # frontend warnings
				self.warnings.append(line)
			elif " error: " in line: # frontend errors
				self.errors.append(line)
			elif line.startswith("Verify warning:"): # libfirm verifier warnings
				self.error_msg = "verify warning"
				if not hasattr(self, 'long_error_msg'):
					self.long_error_msg = ""
				self.long_error_msg += line+"\n"
				return False
			elif "libFirm panic" in line:
				self.errors_msg = "libFirm panic"
				return False
			elif "linker reported an error" in line:
				self.error_msg = "linker error"
				return False
			elif "assembler reported an error" in line:
				self.error_msg = "assembler error"
				return False
		return True

	def check_compiler_errors(self):
		if len(self.errors) > 0:
			self.error_msg = "%d compile errors" % len(self.errors)
			return False
		if self.compile_retcode != 0:
			self.error_msg = "compilation not ok (returncode %d)" % self.compile_retcode
			return False
		return True

	def _compile_asm(self):
		"""Compile the test program to assembler"""
		environment = self.environment
		ensure_dir(os.path.dirname(environment.asm_file))
		cmd = "%(compiler)s -S %(filename)s %(cflags)s %(ldflags)s -o %(asm_file)s" % environment.__dict__
		my_execute(cmd) # assumed to succeed, because compile to exe did

	def check_reference_output(self, out):
		if not hasattr(self.environment, 'reference_output'):
			self.error_msg = "no reference output"
			if out:
				out = "Output was:\n" + out
			else:
				out = "Empty Output."
			self.long_error_msg = "Add .ref file for this test case! " + out
			return False
		ref = self.environment.reference_output
		if out == ref:
			return True

		self.error_msg = "output mismatch"
		# Try to create a diff
		try:
			ref  = self.environment.reference_output.decode("utf-8").splitlines()
			diff = "\n".join(difflib.unified_diff(out.decode("utf-8").splitlines(), ref))
			self.long_error_msg = diff
		except:
			self.long_error_msg = "unable to compare output/reference"
			# We might end up here when utf-8 decoding failed
			pass
		return False

	def check_execution(self):
		"""Run compiled test program and compare output to reference"""
		environment = self.environment
		try:
			self.exec_out, self.exec_err, self.exec_retcode = my_execute(environment.runexe + environment.executable + environment.executionargs, timeout=30)
			if self.exec_retcode != 0:
				self.error_msg = "Test return code not zero but %d" % self.exec_retcode
				return False
		except SigKill as e:
			self.error_msg = "execution: %s" % (e.name)
			return False
		except OSError as e:
			self.error_msg = "OSError on execution"
			return False

		# Program run succeeded. Now compare output with reference.
		return self.check_reference_output(self.exec_out)

class CTest(Test):
	def __init__(self, filename, environment):
		super(CTest, self).__init__(filename, environment)
		environment.cflags += " -I%s " % os.path.dirname(environment.filename)

class TestShouldFail(CTest):
	def __init__(self, filename, environment):
		super(TestShouldFail, self).__init__(filename, environment)

	def check_compiler_errors(self):
		if len(self.errors) == 0:
			self.error_msg = "compiler missed error"
			return False
		return True

	def check_execution(self):
		return True # nothing to execute

class TestShouldWarn(CTest):
	def __init__(self, filename, environment):
		super(TestShouldWarn, self).__init__(filename, environment)
		environment.cflags += " -Wall -W"

	def check_compiler_errors(self):
		if not Test.check_compiler_errors(self):
			return False
		warnings = "\n".join(self.warnings) + "\n"
		if not Test.check_reference_output(self, warnings):
			n_warn_out = len(self.warnings)
			if n_warn_out == 0:
				self.error_msg = "compiler missed warnings"
			elif not hasattr(self.environment, 'reference_output'):
				self.error_msg = "compiler reported %d warnings (%s)" % (n_warn_out, self.error_msg)
			else:
				n_warn_ref = len(self.environment.reference_output.splitlines())
				if n_warn_out == n_warn_ref:
					self.error_msg = "compiler reported different warnings"
				else:
					self.error_msg = "compiler reported %d warnings, expected %d"% (n_warn_out, n_warn_ref)
			return False
		return True

	def check_execution(self):
		return True # only check compilation

class TestShouldNotWarn(CTest):
	def __init__(self, filename, environment):
		super(TestShouldNotWarn, self).__init__(filename, environment)
		environment.cflags += " -Wall -W"

	def check_compiler_errors(self):
		if len(self.warnings) > 0:
			self.error_msg = "compiler produced invalid warning"
			return False
		return Test.check_compiler_errors(self)

	def check_execution(self):
		return True # only check compilation

class TestJava(Test):
	def __init__(self, filename, environment):
		super(TestJava, self).__init__(filename, environment)
		if not hasattr(environment, "bytecodec"):
			environment.bytecodec = "bytecode2firm"
			environment.bytecodecflags = ""
		environment.bytecodecflags += "-cp %s" % os.path.dirname(environment.filename)
		environment.mainclass = os.path.basename(environment.filename[:-6])

	def compile(self):
		environment = self.environment
		cmd = "%(bytecodec)s %(bytecodecflags)s %(mainclass)s -o %(executable)s" % environment.__dict__
		self.compile_command = cmd
		self.compiling = ""
		out.write(cmd + "\n")
		try:
			ensure_dir(os.path.dirname(environment.executable))
			self.compile_out, self.compile_err, self.compile_retcode = my_execute(cmd, timeout=30)
		except SigKill as e:
			self.error_msg = "compiler %s (SIG %d)" % (e.name, -e.retcode)
			return False
		return True

	def check_compiler_errors(self):
		if self.compile_retcode != 0:
			self.error_msg = "compilation not ok (returncode %d)" % self.compile_retcode
			return False
		return True

	def _compile_asm(self):
		self.error_msg = "bytecode->asm not implemented yet"
		return False

class DummyTest:
	def run(self):
		self.success = True

def load_expectations(url, environment):
	try:
		fetched = True
		input = urlopen(url)
		if input.getcode() != None and input.getcode() != 200:
			fetched = False
	except:
		fetched = False

	cachefile = environment.builddir + "/" + os.path.basename(url)
	if not fetched:
		out.write("Warning: Couldn't download from '%s', using cache file\n" % url)
		input = open(cachefile)

	result = dict()
	for line in input:
		line = line.decode("utf-8")
		try:
			i = line.index(" ")
		except ValueError:
			continue
		test_id = line[:i]
		error_msg = line[i:].strip()
		result[test_id] = error_msg

	cache = open(cachefile, "w")
	for (test_id, error_msg) in result.iteritems():
		cache.write("%-40s %s\n" % (test_id, error_msg))
	cache.close()

	return result
_EXPECTATIONS = {}

def expectation_match(error, expectation):
	if error.endswith(" compile errors") and expectation.endswith(" compile errors"):
		# exact number of compile errors does not matter
		return True
	if error == "compiler: SIGXCPU" and expectation == "compiler: SIGKILL":
		# BSD on timeout signals SIGXCPU and Linux SIGKILL
		return True
	if error == "execution: SIGBUS" and expectation == "execution: SIGSEGV":
		# OS X often signals SIGBUS where others signal SIGSEGV
		return True
	return error == expectation

_CONSOLE_RED    = "\033[1;31m"
_CONSOLE_GREEN  = "\033[1;32m"
_CONSOLE_YELLOW = "\033[1;33m"
_CONSOLE_BOLD   = "\033[1m"
_CONSOLE_NORMAL = "\033[m"
_CONSOLE_CLEAR  = "\r\033[K"
_RC = 0 # application return code

def console_output(test, compile_times):
	timing = ""
	prefix = ""
	if compile_times:
		timing = " [%s%.2fs%s]" % (_CONSOLE_YELLOW, test.compile_seconds, _CONSOLE_NORMAL)
	error_msg = test.error_msg
	expected  = _EXPECTATIONS.get(test.id)
	if expected and expectation_match(error_msg, expected):
		if test.success and not _VERBOSE:
			out.write("%s%s..." % (_CONSOLE_CLEAR, test.id))
			out.flush()
			return
	else:
		if test.success:
			prefix = _CONSOLE_GREEN
		elif expected and expected != "ok":
			prefix = _CONSOLE_YELLOW
		else:
			prefix = _CONSOLE_RED

		if expected and not test.success:
			global _RC
			_RC = 1

		if expected:
			error_msg += " (expected %s)" % expected
		else:
			error_msg += " (new)"
	out.write("%s%s%-40s %s%s%s\n" % (_CONSOLE_CLEAR, prefix, test.id, error_msg, _CONSOLE_NORMAL, timing))
	out.flush()

class Report:
	def __init__(self):
		self.xml = ET.Element("results")
		self.tests = list()
		self.summary = (0,0)

	def addTest(self, test):
		self.tests.append(test)

	def printSummary(self):
		out.write("%s---------------------------\n" % (_CONSOLE_CLEAR))
		out.write("Ran %d tests, of which %s%d failed%s.\n" %\
			(self.summary[0], _CONSOLE_BOLD, self.summary[1], _CONSOLE_NORMAL))
		out.flush()

	def writeXML(self, fh, config):
		xml = ET.Element("results")
		ET.SubElement(xml, "datetime").text = str(datetime.now())
		ET.SubElement(xml, "reportname").text = _REPORT_NAME
		env = ET.SubElement(xml, "environment")
		for (key,value) in config.__dict__.items():
			ET.SubElement(env, key).text = str(value)
		env.tail = "\n" # pretty print
		for test in self.tests:
			self._addTestXML(xml, test)
		summary = ET.SubElement(xml, "summary")
		ET.SubElement(summary, "total").text = str(self.summary[0])
		ET.SubElement(summary, "failed").text = str(self.summary[1])
		tree = ET.ElementTree(xml)
		tree.write(fh, encoding=_XML_ENCODING)

	def writeFaillog(self, fh, config):
		for test in self.tests:
			fh.write("%-40s %s\n" % (test.id, test.error_msg))

	def _addTestXML(self, xml, test):
		fail = not test.success
		result = ET.SubElement(xml, "result")
		result.set("id", test.id)
		result.set("ok", str(int(test.success)))
		result.set("error", test.error_msg)
		result.set("run_seconds", "%.2f" % (test.run_seconds))
		result.set("compile_seconds", "%.2f" % (test.compile_seconds))
		if _DEBUG:
			result.set("compile_command", test.compile_command)
		if not test.success and hasattr(test, 'long_error_msg'):
			result.text = test.long_error_msg
		result.tail = "\n" # pretty print
		self.summary = (self.summary[0]+1, self.summary[1]+int(fail))

def is_c_file(name):
	return name.endswith(".c") or name.endswith(".cc")

test_factories = [
	( lambda name: is_c_file(name) and "should_fail/" in name, TestShouldFail ),
	( lambda name: is_c_file(name) and "should_warn/" in name, TestShouldWarn ),
	( lambda name: is_c_file(name) and "nowarn/" in name, TestShouldNotWarn),
	( lambda name: is_c_file(name), CTest ),
	( lambda name: name.endswith(".class"), TestJava ),
]
_EXTENSIONS = ["c", "cc", "class"]

def make_test(environment, filename):
	environment = deepcopy(environment)
	# Set environment properties based on directory
	if filename.startswith("C/gnu90"):
		environment.cflags += " -std=gnu90"
	elif filename.startswith("C/gnu99"):
		environment.cflags += " -std=gnu99"
	elif filename.startswith("C/MS"):
		environment.cflags += " --ms"
	elif filename.startswith("C/"):
		environment.cflags += " -std=c99"

	# Determine Tester to be used
	testclass = None
	for (test,cls) in test_factories:
		if test(filename):
			testclass = cls
			break
	if testclass == None:
		sys.stderr.write("Couldn't determine tester for '%s'" % filename)
		testclass = DummyTest

	return testclass(filename, environment)

def find_files(directory):
	for ext in _EXTENSIONS:
		for name in glob("%s/*.%s" % (directory, ext)):
			yield name

def run_test(test):
	try:
		test.run()
	except Exception as e: # Exception in test run
		sys.stderr.write("Exception in %s: %s\n" % (test.id, e))
		raise e
	return test

def default_create_testset(config, args):
	global TESTS
	if not args:
		args = _DEFAULT_DIRS + _ARCH_DIRS

	for test in args:
		if os.path.isdir(test):
			for fname in sorted(find_files(test)):
				TESTS.append(make_test(config, fname))
		else:
			TESTS.append(make_test(config, test))

CREATE_TESTSET = default_create_testset

def makereport(config, args):
	init(config)

	global _EXPECTATIONS
	try:
		_EXPECTATIONS = load_expectations(config.expect_url, config)
	except Exception as e:
		out.write("Couldn't load fail expectations: %s\n" % e)
		_EXPECTATIONS = {}

	global CREATE_TESTSET
	CREATE_TESTSET(config, args)

	# create test futures for parallel evaluation
	global TESTS
	global EXECUTOR
	queue = list()
	EXECUTOR = ProcessPoolExecutor(max_workers = config.threads)
	for test in TESTS:
		queue.append(EXECUTOR.submit(run_test, test))

	# collect report
	r = Report()
	try:
		found = {}
		for promise in queue:
			test = promise.result()
			found[test.id] = True
			console_output(test, config.compile_times)
			r.addTest(test)
		if config.show_disappeared:
			for t in _EXPECTATIONS:
				if t not in found:
					out.write("%s%-40s %s%s\n" % (_CONSOLE_RED, t, "test disappeared", _CONSOLE_NORMAL))
					out.flush()

	except KeyboardInterrupt:
		out.write("Received interrupt signal, shutting down\n")
		for promise in queue:
			promise.cancel()
		EXECUTOR.shutdown(wait=False)
		pass
	r.writeXML(open(config.reportdir + "/" + _REPORT_NAME + ".xml", 'w'), config)
	faillog_out = config.faillog_out
	if faillog_out == None:
		faillog_out = config.reportdir + "/" + _REPORT_NAME + ".faillog"
	r.writeFaillog(open(faillog_out, 'w'), config)
	r.printSummary()

def init(config):
	ensure_dir(config.reportdir)
	ensure_dir(config.builddir)

def main():
	global _RC
	global _VERBOSE
	global _DEBUG
	os.putenv("LC_ALL", "C") # need english error messages in gcc ;)

	# Add new commandline options for all configurations
	for (config,setupfunc) in configurations.items():
		_OPTS.add_option("--%s" % config, action="callback", callback=setupfunc,
		                 help="activate %s configuration" % config)

	config, args = _OPTS.parse_args()
	# If no plugin has set custom cflags, use default
	if config.cflags == "":
		config.cflags = "-march=native -m32"
	config.cflags += " -O3" # Always optimize
	_DEBUG         = config.debug
	_VERBOSE       = config.verbose
	makereport(config, args)
	return _RC

# Look for plugins
pluginlist = list(glob("*/reportplugin.py"))
pluginlist += list(glob("configs/*.py"))
for plugin in pluginlist:
	exec(compile(open(plugin).read(), plugin, 'exec'))

if __name__ == "__main__":
	sys.exit(main())
